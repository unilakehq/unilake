use tokio_util::bytes::Buf;

use super::{
    TdsMessageCodec, TdsToken, TdsTokenCodec, TdsTokenType, TokenColMetaData, TokenDone,
    TokenEnvChange, TokenError, TokenInfo, TokenLoginAck, TokenOrder, TokenReturnValue,
};

#[derive(Debug)]
pub struct ResponseMessage {
    tokens: Vec<TdsToken>,
}

impl ResponseMessage {
    pub fn new() -> Self {
        ResponseMessage { tokens: Vec::new() }
    }

    pub fn add_token(&mut self, token: TdsToken) {
        self.tokens.push(token);
    }
}

impl TdsMessageCodec for ResponseMessage {
    fn decode(
        src: &mut tokio_util::bytes::BytesMut,
    ) -> crate::error::TdsWireResult<super::TdsMessage>
    where
        Self: Sized,
    {
        let mut ret = ResponseMessage::new();
        while src.has_remaining() {
            // todo(mrhamburg): remove unwrap
            let token_type = TdsTokenType::try_from(src.get_u8()).unwrap();

            let token = match token_type {
                TdsTokenType::ColMetaData => TokenColMetaData::decode(src)?,
                TdsTokenType::Error => TokenError::decode(src)?,
                TdsTokenType::Info => TokenInfo::decode(src)?,
                TdsTokenType::Order => TokenOrder::decode(src)?,
                TdsTokenType::ReturnValue => TokenReturnValue::decode(src)?,
                TdsTokenType::LoginAck => TokenLoginAck::decode(src)?,
                TdsTokenType::Row => todo!(),
                TdsTokenType::NbcRow => todo!(),
                TdsTokenType::Sspi => todo!(),
                TdsTokenType::EnvChange => TokenEnvChange::decode(src)?,
                TdsTokenType::Done => TokenDone::decode(src)?,
                TdsTokenType::DoneProc => todo!(),
                TdsTokenType::DoneInProc => todo!(),
                TdsTokenType::FeatureExtAck => todo!(),
                TdsTokenType::FedAuthInfo => todo!(),
                TdsTokenType::SessionState => todo!(),
                _ => panic!("Unknown token type: {:?}", token_type),
            };
            ret.add_token(token);
        }

        Ok(super::TdsMessage::Response(ret))
    }

    fn encode(&self, dst: &mut tokio_util::bytes::BytesMut) -> crate::error::TdsWireResult<()> {
        todo!()
    }
}

#[cfg(test)]
mod tests {
    use tokio_util::bytes::BytesMut;

    use crate::{error::TdsWireResult, PacketHeader, TdsMessage};

    use super::*;

    const RAW_BYTES: &[u8] = &[
        0x04, 0x01, 0x01, 0x61, 0x00, 0x00, 0x01, 0x00, 0xE3, 0x1B, 0x00, 0x01, 0x06, 0x6D, 0x00,
        0x61, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x06, 0x6D, 0x00, 0x61, 0x00,
        0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0xAB, 0x58, 0x00, 0x45, 0x16, 0x00, 0x00,
        0x02, 0x00, 0x25, 0x00, 0x43, 0x00, 0x68, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x65,
        0x00, 0x64, 0x00, 0x20, 0x00, 0x64, 0x00, 0x61, 0x00, 0x74, 0x00, 0x61, 0x00, 0x62, 0x00,
        0x61, 0x00, 0x73, 0x00, 0x65, 0x00, 0x20, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74,
        0x00, 0x65, 0x00, 0x78, 0x00, 0x74, 0x00, 0x20, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x20, 0x00,
        0x27, 0x00, 0x6D, 0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x27,
        0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x08, 0x00, 0x07, 0x05, 0x09,
        0x04, 0xD0, 0x00, 0x34, 0x00, 0xE3, 0x17, 0x00, 0x02, 0x0A, 0x75, 0x00, 0x73, 0x00, 0x5F,
        0x00, 0x65, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x73, 0x00, 0x68, 0x00,
        0x00, 0xE3, 0x13, 0x00, 0x04, 0x04, 0x34, 0x00, 0x30, 0x00, 0x39, 0x00, 0x36, 0x00, 0x04,
        0x34, 0x00, 0x30, 0x00, 0x39, 0x00, 0x36, 0x00, 0xAB, 0x5C, 0x00, 0x47, 0x16, 0x00, 0x00,
        0x01, 0x00, 0x27, 0x00, 0x43, 0x00, 0x68, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x65,
        0x00, 0x64, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x75, 0x00,
        0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x20, 0x00, 0x73, 0x00, 0x65, 0x00, 0x74, 0x00, 0x74,
        0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x20, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x20, 0x00,
        0x75, 0x00, 0x73, 0x00, 0x5F, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x6C, 0x00, 0x69,
        0x00, 0x73, 0x00, 0x68, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x36,
        0x00, 0x01, 0x72, 0x09, 0x00, 0x02, 0x16, 0x4D, 0x00, 0x69, 0x00, 0x63, 0x00, 0x72, 0x00,
        0x6F, 0x00, 0x73, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x74, 0x00, 0x20, 0x00, 0x53, 0x00, 0x51,
        0x00, 0x4C, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x76, 0x00, 0x65, 0x00,
        0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn raw_encode() -> TdsWireResult<()> {
        let mut bytes = BytesMut::from(&RAW_BYTES[..]);
        let header = PacketHeader::decode(&mut bytes).unwrap();
        let message = ResponseMessage::decode(&mut bytes).unwrap();
        if let TdsMessage::Response(message) = message {
            assert_eq!(header.length, 234);
            assert_eq!(message.tokens.len(), 1);
        } else {
            panic!("unexpected message type: {:?}", message);
        }
        Ok(())
    }
}
