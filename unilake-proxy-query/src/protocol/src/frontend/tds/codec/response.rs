use tokio_util::bytes::{Buf, BytesMut};

use super::{
    TdsMessageCodec, TdsToken, TdsTokenCodec, TdsTokenType, TokenColMetaData, TokenInfo,
    TokenLoginAck, TokenOrder, TokenReturnValue,
};

use unilake_common::error::{TdsWireError, TdsWireResult, TokenError};

#[derive(Debug)]
pub struct ResponseMessage {
    tokens: Vec<TdsToken>,
}

impl ResponseMessage {
    pub fn new() -> Self {
        ResponseMessage { tokens: Vec::new() }
    }

    pub fn add_token(&mut self, token: TdsToken) {
        self.tokens.push(token);
    }

    pub fn add_token_at_index(&mut self, token: TdsToken, index: usize) {
        self.tokens.insert(index, token);
    }

    fn inner_encode(token: &TdsToken, dst: &mut BytesMut) -> TdsWireResult<()> {
        match token {
            TdsToken::Done(token) => token.encode(dst),
            TdsToken::EnvChange(token) => token.encode(dst),
            TdsToken::Error(token) => token.encode(dst),
            TdsToken::Info(token) => token.encode(dst),
            TdsToken::Order(token) => token.encode(dst),
            TdsToken::FeatureExtAck(token) => token.encode(dst),
            TdsToken::ColMetaData(token) => token.encode(dst),
            TdsToken::FedAuth(token) => token.encode(dst),
            TdsToken::LoginAck(token) => token.encode(dst),
            TdsToken::ReturnValue(token) => token.encode(dst),
            TdsToken::Row(token) => token.encode(dst),
            TdsToken::SessionState(token) => token.encode(dst),
            // TdsToken::Sspi(token) => token.encode(dst),
            _ => unimplemented!(),
        }
    }
}

impl TdsMessageCodec for ResponseMessage {
    fn decode(src: &mut BytesMut) -> TdsWireResult<super::TdsMessage>
    where
        Self: Sized,
    {
        let mut ret = ResponseMessage::new();
        while src.has_remaining() {
            let token_type = TdsTokenType::try_from(src.get_u8())
                .map_err(|_| TdsWireError::Protocol("Unknown token type".to_string()))?;

            let token = match token_type {
                TdsTokenType::ColMetaData => TokenColMetaData::decode(src)?,
                TdsTokenType::Error => TokenError::decode(src)?,
                TdsTokenType::Info => TokenInfo::decode(src)?,
                TdsTokenType::Order => TokenOrder::decode(src)?,
                TdsTokenType::ReturnValue => TokenReturnValue::decode(src)?,
                TdsTokenType::LoginAck => TokenLoginAck::decode(src)?,
                _ => todo!(),
            };
            ret.add_token(token);
        }

        Ok(super::TdsMessage::Response(ret))
    }

    fn encode(&self, dst: &mut BytesMut) -> TdsWireResult<()> {
        self.tokens
            .iter()
            .try_for_each(|token| Self::inner_encode(token, dst))?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use tokio_util::bytes::BytesMut;

    use crate::frontend::{PacketHeader, TdsMessage};

    use super::*;

    const RAW_BYTES: &[u8] = &[
        0x04, 0x01, 0x01, 0x61, 0x00, 0x00, 0x01, 0x00, 0xE3, 0x1B, 0x00, 0x01, 0x06, 0x6D, 0x00,
        0x61, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x06, 0x6D, 0x00, 0x61, 0x00,
        0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0xAB, 0x58, 0x00, 0x45, 0x16, 0x00, 0x00,
        0x02, 0x00, 0x25, 0x00, 0x43, 0x00, 0x68, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x65,
        0x00, 0x64, 0x00, 0x20, 0x00, 0x64, 0x00, 0x61, 0x00, 0x74, 0x00, 0x61, 0x00, 0x62, 0x00,
        0x61, 0x00, 0x73, 0x00, 0x65, 0x00, 0x20, 0x00, 0x63, 0x00, 0x6F, 0x00, 0x6E, 0x00, 0x74,
        0x00, 0x65, 0x00, 0x78, 0x00, 0x74, 0x00, 0x20, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x20, 0x00,
        0x27, 0x00, 0x6D, 0x00, 0x61, 0x00, 0x73, 0x00, 0x74, 0x00, 0x65, 0x00, 0x72, 0x00, 0x27,
        0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x08, 0x00, 0x07, 0x05, 0x09,
        0x04, 0xD0, 0x00, 0x34, 0x00, 0xE3, 0x17, 0x00, 0x02, 0x0A, 0x75, 0x00, 0x73, 0x00, 0x5F,
        0x00, 0x65, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x6C, 0x00, 0x69, 0x00, 0x73, 0x00, 0x68, 0x00,
        0x00, 0xE3, 0x13, 0x00, 0x04, 0x04, 0x34, 0x00, 0x30, 0x00, 0x39, 0x00, 0x36, 0x00, 0x04,
        0x34, 0x00, 0x30, 0x00, 0x39, 0x00, 0x36, 0x00, 0xAB, 0x5C, 0x00, 0x47, 0x16, 0x00, 0x00,
        0x01, 0x00, 0x27, 0x00, 0x43, 0x00, 0x68, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x65,
        0x00, 0x64, 0x00, 0x20, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x75, 0x00,
        0x61, 0x00, 0x67, 0x00, 0x65, 0x00, 0x20, 0x00, 0x73, 0x00, 0x65, 0x00, 0x74, 0x00, 0x74,
        0x00, 0x69, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x20, 0x00, 0x74, 0x00, 0x6F, 0x00, 0x20, 0x00,
        0x75, 0x00, 0x73, 0x00, 0x5F, 0x00, 0x65, 0x00, 0x6E, 0x00, 0x67, 0x00, 0x6C, 0x00, 0x69,
        0x00, 0x73, 0x00, 0x68, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x36,
        0x00, 0x01, 0x72, 0x09, 0x00, 0x02, 0x16, 0x4D, 0x00, 0x69, 0x00, 0x63, 0x00, 0x72, 0x00,
        0x6F, 0x00, 0x73, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x74, 0x00, 0x20, 0x00, 0x53, 0x00, 0x51,
        0x00, 0x4C, 0x00, 0x20, 0x00, 0x53, 0x00, 0x65, 0x00, 0x72, 0x00, 0x76, 0x00, 0x65, 0x00,
        0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    #[test]
    fn raw_decode_test() -> TdsWireResult<()> {
        raw_decode().unwrap();
        Ok(())
    }

    fn raw_decode() -> TdsWireResult<ResponseMessage> {
        let mut bytes = BytesMut::from(&RAW_BYTES[..]);
        let header = PacketHeader::decode(&mut bytes).unwrap();
        let message = ResponseMessage::decode(&mut bytes).unwrap();
        if let TdsMessage::Response(message) = message {
            assert_eq!(header.length, RAW_BYTES.len() as u16);
            assert_eq!(message.tokens.len(), 8);
            Ok(message)
        } else {
            panic!("unexpected message type: {:?}", message);
        }
    }

    #[test]
    fn raw_encode_roundtrip() -> TdsWireResult<()> {
        let sut = raw_decode().unwrap();
        let mut bytes = BytesMut::new();
        sut.encode(&mut bytes).unwrap();
        Ok(())
    }
}
